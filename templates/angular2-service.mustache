import { Injectable } from '@angular/core';
import { Http, Response, Headers } from '@angular/http';
{{#definitions}}
import { {{name}} } from './models/{{&className}}_models';
{{/definitions}} 

@Injectable()
export class {{&className}}ApiClientService {
	
	domain:string;
	
	constructor(public http: Http, options?: any) {
		var domain = (typeof options === 'object') ? options.domain : options;
		this.domain = typeof(domain) === 'string' ? domain : '{{&domain}}';
		
		if(this.domain.length === 0) {
			throw new Error('Domain parameter must be specified as a string.');
		}
	}


{{#methods}}
	/**
	* {{&summary}}
	* @method
	* @name {{&methodName}}
	{{#parameters}}
	{{^isSingleton}}* @param {{=<% %>=}}{<%&type%>}<%={{ }}=%> {{&camelCaseName}} - {{&description}}{{/isSingleton}}
	{{/parameters}}
	* 
	*/
	public {{&methodName}}({{#parameters}}{{&camelCaseName}}: {{typescriptType}}{{^last}}, {{/last}}{{/parameters}}) : Promise<{ status: number, payload: {{responseTypes}} }> {
		var uri = '{{&path}}';
		var payload = {};	
		var queryParameters = {};
		let headers = new Headers();
		headers.append('Content-Type', 'application/json');
		
{{#parameters}}
			{{#isQueryParameter}}
			{{#isSingleton}}
		queryParameters['{{&name}}'] = '{{&singleton}}';
			{{/isSingleton}}
			{{^isSingleton}}
			{{#isPatternType}}
		Object.keys(parameters).forEach(function(parameterName) {
			if(new RegExp('{{&pattern}}').test(parameterName)){
				queryParameters[parameterName] = parameters[parameterName];
			}
		});
			{{/isPatternType}}
			{{^isPatternType}}
		if({{&camelCaseName}} !== undefined){
			queryParameters['{{&name}}'] = {{&camelCaseName}};
		}
			{{/isPatternType}}
			{{/isSingleton}}
			{{/isQueryParameter}}
			{{#isPathParameter}}
		uri = uri.replace('{{=<% %>=}}{<%&name%>}<%={{ }}=%>', {{&camelCaseName}});
			{{/isPathParameter}}
			{{#isHeaderParameter}}
			{{#isSingleton}}
		headers.append('{{&name}}', '{{&singleton}}');
			{{/isSingleton}}
			{{^isSingleton}}
		if(parameters['{{&camelCaseName}}'] !== undefined){
			headers.append('{{&name}}', parameters['{{&camelCaseName}}']);
		}
			{{/isSingleton}}
			{{/isHeaderParameter}}
			{{#isBodyParameter}}
		payload['{{&name}}'] = {{&camelCaseName}};
			{{/isBodyParameter}}
			{{#isFormParameter}}
			{{#isSingleton}}
		form['{{&name}}'] = '{{&singleton}}';
			{{/isSingleton}}
			{{^isSingleton}}
		if(parameters['{{&camelCaseName}}'] !== undefined){
			form['{{&name}}'] = parameters['{{&camelCaseName}}'];
		}
			{{/isSingleton}}
			{{/isFormParameter}}
{{/parameters}}		
	
		return this.http
			.{{angular2httpMethod}}(this.domain + uri, payload, { headers: headers, params: queryParameters }).toPromise()
			.then((res: Response) => {
			   {{#hasJsonResponse}}
			   return new Promise<{ status: number, payload: {{responseTypes}} }>((resolve, reject) => {
				    {{#responses}}
				    if(res.status == {{status}}) {
				    	{{#void}}
				    	resolve({status: {{status}}, payload: null });
				    	{{/void}}
				    	{{^void}}
				    	{{#baseType}}
				    	resolve({status: {{status}}, payload: res.text(){{#isArray}}[]{{/isArray}}})
				    	{{/baseType}}
				    	{{^baseType}}
				    	resolve({status: {{status}}, payload: res.json() as {{typescriptType}}{{#isArray}}[]{{/isArray}} });
				    	{{/baseType}} 
				    	{{/void}}
				    	return;
				    }
				    {{/responses}}
    
				    reject(res.toString());
					return;
				});
			   {{/hasJsonResponse}}
			   {{^hasJsonResponse}}
			   var result = null;
			   
			   // TODO: this method does not return JSON response, so you need to handle response by your own
			   {{/hasJsonResponse}}              
            });
	}
	
{{/methods}}

}